
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://adversarr.github.io/ps/Wiki/Collision/%E7%BB%BC%E8%BF%B0/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93/%E7%BB%BC%E5%90%88/">
      
      
      
      
      <link rel="icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.8">
    
    
      
        <title>综合 - PS is not Physical Simulation</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.4b4a2bd9.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../.." title="PS is not Physical Simulation" class="md-header__button md-logo" aria-label="PS is not Physical Simulation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            PS is not Physical Simulation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              综合
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../../Papers/" class="md-tabs__link">
        
  
    
  
  Papers

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../../registry/" class="md-tabs__link">
        
  
    
  
  Registry

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../../tags/" class="md-tabs__link">
        
  
    
  
  Tags

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../" class="md-tabs__link">
        
  
    
  
  Wiki

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="PS is not Physical Simulation" class="md-nav__button md-logo" aria-label="PS is not Physical Simulation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    PS is not Physical Simulation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../Papers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Papers
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../registry/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Registry
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../tags/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tags
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Wiki
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  

<nav class="md-nav md-nav--secondary" aria-label="On this page">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      On this page
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    碰撞处理简述
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-introduction" class="md-nav__link">
    碰撞检测 -- Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#broad-phase" class="md-nav__link">
    Broad-Phase
  </a>
  
    <nav class="md-nav" aria-label="Broad-Phase">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    加速结构
  </a>
  
    <nav class="md-nav" aria-label="加速结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oct-treekdtree" class="md-nav__link">
    OCT-tree/kdTree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bvh" class="md-nav__link">
    BVH
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spatial-hashing-spatial-partitioning" class="md-nav__link">
    Spatial Hashing / Spatial Partitioning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mid-phase" class="md-nav__link">
    Mid-Phase
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#narrow-phase-1" class="md-nav__link">
    Narrow-phase 1 刚体
  </a>
  
    <nav class="md-nav" aria-label="Narrow-phase 1 刚体">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dcd" class="md-nav__link">
    DCD
  </a>
  
    <nav class="md-nav" aria-label="DCD">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#signed-distance-function" class="md-nav__link">
    Signed Distance Function
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dcd_1" class="md-nav__link">
    凸包/刚体的DCD计算
  </a>
  
    <nav class="md-nav" aria-label="凸包/刚体的DCD计算">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gjk" class="md-nav__link">
    GJK算法
  </a>
  
    <nav class="md-nav" aria-label="GJK算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#idea" class="md-nav__link">
    Idea
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#support-simplex" class="md-nav__link">
    Support 函数和 Simplex 单纯形
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    迭代求解
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sat" class="md-nav__link">
    SAT算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    凸包分解和碰撞检测
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ccd" class="md-nav__link">
    CCD
  </a>
  
    <nav class="md-nav" aria-label="CCD">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    代数方程求解
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ccd_1" class="md-nav__link">
    “近似CCD”
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    二分搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#swept-volumn" class="md-nav__link">
    Swept Volumn
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#speculative-ccd" class="md-nav__link">
    Speculative CCD
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ray-cast" class="md-nav__link">
    Ray-cast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conservasive-advancement" class="md-nav__link">
    Conservasive Advancement
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#narrow-phase-2" class="md-nav__link">
    Narrow-Phase 2 变形体
  </a>
  
    <nav class="md-nav" aria-label="Narrow-Phase 2 变形体">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dcd_2" class="md-nav__link">
    DCD
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ccd_2" class="md-nav__link">
    CCD
  </a>
  
    <nav class="md-nav" aria-label="CCD">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#preliminaries" class="md-nav__link">
    Preliminaries
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    二分法
  </a>
  
    <nav class="md-nav" aria-label="二分法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#irf" class="md-nav__link">
    IRF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uirf" class="md-nav__link">
    UIRF
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    针对三角网格的三次方程求解方法
  </a>
  
    <nav class="md-nav" aria-label="针对三角网格的三次方程求解方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fprf" class="md-nav__link">
    FPRF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tightccd" class="md-nav__link">
    TightCCD
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsc" class="md-nav__link">
    BSC
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rp-rrp" class="md-nav__link">
    光线投射 RP / RRP
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    碰撞处理
  </a>
  
    <nav class="md-nav" aria-label="碰撞处理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#interior-point-method" class="md-nav__link">
    Interior Point Method 内点法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#impact-zone-optimization" class="md-nav__link">
    Impact Zone Optimization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#untangle-cloth" class="md-nav__link">
    相交解除 — Untangle Cloth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rigid-impact-zone" class="md-nav__link">
    Rigid Impact Zone
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    非接触方法
  </a>
  
    <nav class="md-nav" aria-label="非接触方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ipc" class="md-nav__link">
    IPC
  </a>
  
    <nav class="md-nav" aria-label="IPC">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    如何计算 “距离”
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constraint-set" class="md-nav__link">
    Constraint Set
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    迭代过程中如何保证约束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#siggraph-2021-repulsion-method" class="md-nav__link">
    SIGGRAPH 2021 -- Repulsion Method
  </a>
  
    <nav class="md-nav" aria-label="SIGGRAPH 2021 -- Repulsion Method">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#soft-phase" class="md-nav__link">
    Soft-Phase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hard-phase" class="md-nav__link">
    Hard-Phase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptive-resampling" class="md-nav__link">
    Adaptive Resampling
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p>Hierarchy in wiki:</p>
<ul>
<li><a href="../../../../">Wiki/</a></li>
<li><a href="../../../">Wiki/Collision/</a></li>
<li><a href="../">Wiki/Collision/%E7%BB%BC%E8%BF%B0/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93/</a></li>
</ul>
<hr>
<h1 id="_1">综合</h1>
<h2 id="_2">碰撞处理简述</h2>
<p>碰撞处理的难度是不大的，主要问题是如何进行快速、准确的碰撞检测。碰撞检测主要算法执行流程如下图：</p>
<p><img alt="GAMES-103-Wang" src="../assets/2022-04-05-17-32-22-20221202161849-t6ctuee.png"/></p>
<h2 id="-introduction">碰撞检测 -- Introduction</h2>
<p>首先再次引一下 PhyX 里面的内容，这也是这篇文章整体的一个思路。</p>
<blockquote>
<p><strong>Overview of Collision in PhysX</strong></p>
<ul>
<li>Broad Phase</li>
<li>AABB vs AABB, 3 axis sweep and prune</li>
<li>Mid Phase</li>
<li>AABB tree vs (AABB, OBB, sphere,capsule,plane, ray) – OPCODE AABB tree</li>
</ul>
<p>对于 Narrow Phase：</p>
<ul>
<li>
<p>流体-SPH Fluids (CCD)</p>
</li>
<li>
<p>Particles vs static triangle mesh • Particles vs dynamic primitives</p>
</li>
<li>
<p>布料-Cloth (CCD)</p>
</li>
<li>
<p>Vertices vs static triangle mesh • Vertices vs dynamic primitives</p>
</li>
<li>
<p>刚体-Rigid body (Discrete) – GJK or SAT</p>
</li>
<li>
<p>Convex mesh and primitives vs static triangle mesh</p>
</li>
<li>Convex, primitives vs Convex, primitives</li>
</ul>
</blockquote>
<p>解释一些事情：</p>
<ol>
<li>对于<strong>大多数</strong>情况下的碰撞，我们只考虑<strong>物体之间</strong>的情况，而不是物体内部。</li>
<li>Broad-Phase做的实际上是<em>生成式</em>的，而非<em>筛选式</em>的，Mid-Phase对于Broad-Phase进行筛选，Narrow-Phase是筛选结果来精确计算是否真正发生了碰撞。</li>
</ol>
<blockquote>
<p>很多研究认为 Narrow-Phase 的效率并不需要太多考虑，而前两个筛选的效率大大影响了结果</p>
<ol>
<li>对于Narrow-Phase中的三类物体，它们有不同的属性：</li>
</ol>
</blockquote>
<ol>
<li>流体 -- SPH模拟假设为一个个小的水块，自相交检测策略不同</li>
<li>布料 -- Mass-Spring or PBD，约束为任何物体不能穿透布料表面，也适用于自身，所以需要进行自碰撞处理</li>
<li>刚体 -- 不可能发生自碰撞，只考虑物体之间的碰撞。</li>
</ol>
<h2 id="broad-phase">Broad-Phase</h2>
<p>实际上这个没啥好讲的，主要思路就是建立空间数据结构，然后加速计算。</p>
<ol>
<li>BVHs</li>
<li>Spatial Hashing</li>
</ol>
<h3 id="_3">加速结构</h3>
<p>就如之前提到的，Broad-Phase主要是使用<strong>空间数据结构</strong>来加速碰撞检查，这类数据结构按照欧氏空间的坐标来对于整个空间进行索引加速，从而实现快速查找近邻的目的。</p>
<h4 id="oct-treekdtree">OCT-tree/kdTree</h4>
<ul>
<li><strong>八叉树</strong>：将一个Box按照点<span class="arithmatex">\(P\)</span>和经过<span class="arithmatex">\(P\)</span>平行于<span class="arithmatex">\(xOy,yOz,zOx\)</span>的平面划分。</li>
<li><strong>kd树</strong>：每一次选择一个超平面划分所有点，超平面的选择依照<span class="arithmatex">\(xOy, yOz, zOx,xOy,yOz,\cdots\)</span>的顺序选择。</li>
</ul>
<p>可能碰撞转化为查询轨迹和物体是否相交，等价于查询是否和当前节点的覆盖范围相交，若检查到轨迹和结点覆盖范围</p>
<ol>
<li>相交：</li>
<li>叶子节点，认定为可能碰撞的目标</li>
<li>非叶结点，继续递归查询</li>
<li>不相交： 停止递归查询</li>
</ol>
<p>这样构造层次结构的问题是：</p>
<ol>
<li>过于规则：容易出现不均匀分割，从而导致内存浪费和查询效率下降。</li>
<li>不利于并行计算—这也是层次结构的通病</li>
</ol>
<h4 id="bvh">BVH</h4>
<p>BVH可以看作是OCT-Tree和kdTree的一个推广：Bounding Volumn Hierarchy（BVH） 将全空间进行划分，对于维度为 1 的情况，BVH与<em>线段树</em>几乎没有区别。不过，BVH和OCT-Tree等的最大的区别在于 OCT-Tree 和 kdTree进行划分时使用的是边界去切分整个平面，而BVH用的是<strong>有限体积的“框”</strong>去做空间细分。典型的BVH包括：</p>
<ul>
<li>AABB：轴对齐包围盒</li>
<li>OBB：旋转包围盒</li>
<li>kDOP：k边形包围盒</li>
<li>Bounding Sphere：包围球</li>
</ul>
<p>可以看出，各个算法不同的部分是选用的“框”的形状。另外，在构造上BVH有启发算法，可以是的其构造的层次结构尽量均匀，进一步提高BVH的加速能力。</p>
<h4 id="spatial-hashing-spatial-partitioning">Spatial Hashing / Spatial Partitioning</h4>
<p>Spatial Hashing 的思想是为每一个空间一个编号。最简单的方法是均匀的使用格点来对于全空间进行划分。最基础的 Spatial Hashing 在为每一个格子建立列表，列表中存放所有和该格子有重合区域的物体（即一个物体可能出现在多个格子内），在查询碰撞时即对于同一列表中的不同物体进行查询即可。</p>
<p><img alt="Spatial Partitioning" src="../assets/image-20220409103734403-20221202161849-ild3yuk.png"/></p>
<p>如图所示，其将全空间划分为16个格子。考虑到减少空间浪费的问题，将这些物体的按id进行排序，即可在不为每一个id建立表格的情况下完成筛选。</p>
<p>该算法的主要问题在于，现代的渲染常常物体、面元分布极不均匀，在可能在几个小的cell中包含大量物体，而产生大量的可能碰撞物体对，极大的降低了其查询效率。</p>
<p>但是得益于其可以轻松在并行计算环境，特别是GPU上进行实现，其在物理引擎中也得到了广泛的应用。</p>
<h3 id="mid-phase">Mid-Phase</h3>
<p>之所以把Mid-Phase放在BroadPhase中是因为它用的算法和数据结构实际上和BroadPhase几乎是一致的。</p>
<p>Mid-Phase会对Broad-Phase筛选出的pair进行进一步筛选，针对每一个物体，其通过细分为更小的物体块（如凸包，面元组等），然后继续应用加速结构进行筛选。</p>
<blockquote>
<p>在这个的基础上还有一些 local 的加速方法，但这也不能算是 Broad-Phase 的方法，因为这个方法针对于 <em>Deformed</em> 的物体进行计算的效率较高。这些方法在曲面上进行划分，相当于在曲面上定义了一个空间划分。比如通过形变能量来指导在其上的空间划分，最后精细化求解使用三次方程法求解。例如：该论文提出，可以依照形变能量，在曲面的表面上建立BVH，来指导Culling进行。</p>
</blockquote>
<p><img alt="Energy-based Self-Collision Culling for Arbitrary Mesh Deformations" src="../assets/image-20220413220403382-20221202161849-ie8rlcz.png"/></p>
<h2 id="narrow-phase-1">Narrow-phase 1 刚体</h2>
<h3 id="dcd">DCD</h3>
<h4 id="signed-distance-function">Signed Distance Function</h4>
<p>如果我们能为刚体定义一个连续函数，使得对于<span class="arithmatex">\(\mathbf x \in \Omega -\partial \Omega\)</span>有<span class="arithmatex">\(\phi(\mathbf x) &lt; 0\)</span>对于所有<span class="arithmatex">\(x\not \in \overline \Omega\)</span>，有<span class="arithmatex">\(\phi(x) &gt; 0\)</span>，则可以很简单的通过函数零点的存在性来判断是否碰撞。</p>
<p>但对于一般的网格，难以定义这样一个带符号的距离函数。</p>
<h4 id="dcd_1">凸包/刚体的DCD计算</h4>
<p>对于一般的刚体之间的碰撞检测，一般采用分解为凸包的算法来进行精准的碰撞检测。因此，最基础的针对凸物体的碰撞检测算法（即凸物体之间的碰撞检测）</p>
<h5 id="gjk">GJK算法</h5>
<h6 id="idea">Idea</h6>
<p>设<span class="arithmatex">\(\mathcal A = \{\mathbf x\}\)</span>，<span class="arithmatex">\(\mathcal B = \{\mathbf x\}\)</span>是两个凸集，定义其 Minkowski 差为：</p>
<div class="arithmatex">\[
\mathcal A - \mathcal B :=\{\mathbf x_1 - \mathbf x_2| \mathbf x_1 \in \mathcal A, \mathbf x_2 \in \mathcal B \}
\]</div>
<p>不难证明，<span class="arithmatex">\(\mathcal A\)</span>和<span class="arithmatex">\(\mathcal B\)</span>碰撞，当且仅当<span class="arithmatex">\(0 \in \mathcal A - \mathcal B\)</span>。</p>
<p>问题在于，我们不可能遍历所有的点对来判断原点是否属于该集合。但是基于这样的基本思路，对于<strong>凸物体</strong>，我们可以有快速算法实现。</p>
<h6 id="support-simplex">Support 函数和 Simplex 单纯形</h6>
<p>其实我们要判断原点是否属于 Minkowski 差，就是要判断是否 Minkowski 差的一个子集包含了<span class="arithmatex">\(0\)</span>，这样的操作可以在物体是凸的的时候要求其形成的单纯形。对于二维的情况，使用三角形；对于三维情况，使用四面体。</p>
<p>为了生成这样的单纯形，我们计算 support 函数来快速获取给定方向上的支撑点，如图所示[^1]。</p>
<p><img alt="" src="../assets/v2-2ac6f479d9ba1510b75d89fd0dbb56f0_1440w-20221202161849-bm30gex.jpg"/></p>
<h6 id="_4">迭代求解</h6>
<p>有了如上的论述，我们可以通过如此构造单纯形：</p>
<ol>
<li>随机生成一个单纯形</li>
<li>假定当前的单纯形为<span class="arithmatex">\(\{v\}\)</span>则选择距离原点最远的抛弃，对于 n - 1 维单纯形求法向量，求support（两个）</li>
<li>直到</li>
<li>检查到 0 =&gt; 碰撞</li>
<li>如果新的support点，在迭代方向上的投影小于等于0 =&gt; 不碰撞</li>
</ol>
<p>可以证明，这样的算法一定在有限步内结束。</p>
<h5 id="sat">SAT算法</h5>
<p>一个更朴素的思想是：（类似于SVM）两个凸集合不交，当且仅当存在一个<span class="arithmatex">\(n - 1\)</span>维的超平面能够完全分开这两个凸集合。 遍历所有的边（三维则是面），投影到其正交补空间上。若<strong>存在</strong>一个边，能使得投影完全分离，则其是不相交的，反之相交。具体实现为遍历所有的边来进行判断。</p>
<h5 id="_5">凸包分解和碰撞检测</h5>
<p>对于一般的刚体，我们可以选择使用<strong>凸包分解（V-HACD）</strong>，将刚体“拆分”成小的凸包。并使用适用于凸包的 Collision Detect 来进行碰撞的判断。</p>
<h3 id="ccd">CCD</h3>
<p>刚体的CCD算法大致有如下几类：</p>
<ol>
<li>求解代数方程</li>
<li>滑动体积法（Swept Volume）</li>
<li>二分搜索</li>
<li>Conservative Advancement
   上述大部分都难以处理一般的多面体情况。但也有一些特殊情况。</li>
</ol>
<!-- 也可以使用分离轴定理计算CCD -->
<h4 id="_6">代数方程求解</h4>
<p>这种方法仅适用于简单而特殊的情况，例如<a href="http://www.realtimerendering.com/intersections.html">Ref</a>：</p>
<ol>
<li>光线</li>
<li>平面</li>
<li>球体、圆柱、圆锥、视锥</li>
<li>AABB、OBB、kDOP</li>
<li>凸包</li>
</ol>
<h4 id="ccd_1">“近似CCD”</h4>
<p>通过减小模拟的时间步长，可以将 DCD 近似为 CCD。</p>
<h4 id="_7">二分搜索</h4>
<p>这个方法仅仅用于确定 TOI</p>
<p>物理模拟中有时会使用二分法（二分搜索）来查找撞击时间：使用这种方案，可以非常快速地到达撞击时间，但我们不涉及Tunnel问题，因为如果在第 i 帧和第 i + 1 帧没有碰撞，二分就不会开始。</p>
<h4 id="swept-volumn">Swept Volumn</h4>
<p>考察<span class="arithmatex">\(t\)</span>和<span class="arithmatex">\(t+1\)</span>时刻物体对应点连线（按物体形状、沿直线执行扫描）构成的体积区域，不难发现，如果有相交，则可能会出现碰撞。计算TOI（碰撞时间）后将物体移动到改时间，执行碰撞处理（如计算速度等）然后重新扫描。</p>
<p>在物体角速度很大的情况下会产生不精确的结果 <a href="https://docs.unity3d.com/Manual/ContinuousCollisionDetection.html">Ref</a>：</p>
<p><img alt="Unity 3D" src="../assets/2022-04-14-15-52-26-20221202161849-uvfpuxf.png"/></p>
<h4 id="speculative-ccd">Speculative CCD</h4>
<p>Speculative CCD 的工作原理是根据物体的速度和角速度，计算物体的AABB，从而推测出下一个物理步骤中所有潜在的接触。然后将所有可能接触送入求解器，以确保满足所有接触约束，以便对象不会通过任何穿模（Tunnel）的情况。求解器使用速度、体积来精确计算CCD。</p>
<p><img alt="" src="../assets/2022-04-14-15-55-41-20221202161849-vvlh6em.png"/></p>
<p>但该方法并不能完全解决所有碰撞问题。考虑如下的情况，小球因为被杆击打而获得更大的速度，先前计算的AABB并不能检测到这样的速度变化：</p>
<p><img alt="" src="../assets/2022-04-14-16-00-14-20221202161849-y8p0co4.png"/></p>
<h4 id="ray-cast">Ray-cast</h4>
<p>小而高速和大而低速物体之间的碰撞检测中可以视作光投射到低速物体上的过程，该方法在 Unreal Engine 中被作为试验性功能提供（支持GPU加速）。算法将光线从对象中心点投射到低速物体上，在高速物体中放置更多的采样点并投射出多条光线，可以获得更好的结果。缺点在于，由于假设了其速度差距极大，该方法不适合计算两个运动的物体的碰撞检测。</p>
<h4 id="conservasive-advancement">Conservasive Advancement</h4>
<blockquote>
<p>Ref:</p>
<ol>
<li>C^2^A: Controlled Conservative Advancement for Continuous Collision Detection of Polygonal Models</li>
</ol>
</blockquote>
<p>在每次迭代中，计算两个对象的最近点（例如使用 GJK）。使用此信息，计算对象可以在避免碰撞的同时移动的安全距离。仅经过几次迭代，就可以找到影响时间。</p>
<h2 id="narrow-phase-2">Narrow-Phase 2 变形体</h2>
<h3 id="dcd_2">DCD</h3>
<p>DCD检查的是如下的方程的解的问题（考察 V-E)：</p>
<div class="arithmatex">\[
\begin{cases}
   \left( ((1-t)\mathbf{x}_a + t \mathbf x _ b - \mathbf x_0 ) \quad \mathbf x _{10} \quad x_{20}\right) = 0\\
   t = (\mathbf x_{0a} \mathbf x_{10}\mathbf  x_{20}) / (\mathbf x_{ba} \mathbf 
   x_{10} \mathbf x_{20})\\
   t \in [0, 1]\\
   \mathbf x(t) \text{ inside } \triangle
\end{cases}
\]</div>
<p>分为三步求解：</p>
<ol>
<li>求解前两行的方程</li>
<li>判断<span class="arithmatex">\(t\)</span>是否在<span class="arithmatex">\([0, 1]\)</span></li>
<li>判断<span class="arithmatex">\(\mathbf x(t)\)</span>是否在三角形内</li>
</ol>
<p>这一部分基本很少有人做，原因在于现代的模拟算法越来越追求计算效率，使用较大的时间步长来进行模拟计算。若仅仅使用DCD，容易产生“穿模”的问题。</p>
<h3 id="ccd_2">CCD</h3>
<p>对于变形体（主要是三角网格）的连续碰撞检测处理算法研究主体还是对于三次方程（即VT/EE条件求解），同时也借鉴了一些在刚体碰撞检测中常用的技巧：</p>
<ol>
<li>二分法</li>
<li>IRF：interval-root-finder</li>
<li>UIRF：Unifromed-Interval-Root-Finder</li>
<li>（针对三角网格）求解三次方程：</li>
<li>FPRF：floating-point time-of-impact root finder</li>
<li>TightCCD(TCCD)</li>
<li>BSC</li>
<li>光线投射</li>
<li>Root Parity(RP)</li>
<li>Rational implementation of RP （RRP）</li>
<li>分割空间微元</li>
</ol>
<h4 id="preliminaries">Preliminaries</h4>
<p>沿用IPC中的记号。对于碰撞检测而言，最基本的模型是假设其在两个迭代步骤之间是线性的，即</p>
<div class="arithmatex">\[
\mathbf x(t) = t \cdot \mathbf x ^{i + 1}  + (1 - t) \cdot \mathbf x ^{i}
\]</div>
<p>其中：</p>
<p>-<span class="arithmatex">\(t\)</span>为归一化后的时间，即<span class="arithmatex">\(t = (t - t_{i}) / (t_{i + 1} - t _i )\)</span>其中右侧的<span class="arithmatex">\(t\)</span>是模拟运行时间
-<span class="arithmatex">\(\mathbf x\)</span>是坐标，是关于时间的函数。上标表示迭代代数</p>
<p>为了简单期间，用<span class="arithmatex">\(\mathcal A = \mathbf x_1\cdots \mathbf x_i\)</span>来表示一个<span class="arithmatex">\(n\)</span>维单纯形，用<span class="arithmatex">\(\mathbf x_{ij}\)</span>来表示<span class="arithmatex">\(\mathbf x_{i} - \mathbf x_{j}\)</span>。</p>
<p>在这样的记号下，碰撞可以用<span class="arithmatex">\(t\)</span>来描述，即：</p>
<p>单纯形<span class="arithmatex">\(\mathcal A = \{\mathbf x_1 \cdots\mathbf x_n\}\)</span>和<span class="arithmatex">\(\mathcal B = \{\mathbf x_1 \cdots \mathbf x_m\}\)</span>碰撞，当且仅当：</p>
<div class="arithmatex">\[
\exists t\in[0, 1]\quad s.t. \  \mathcal A(t) \cap \mathcal B(t) \ne \emptyset
\]</div>
<p>这个公式仅仅是一个定义，并没有很大的计算价值，因此我们需要对于这样的问题进行适当的简化。主要有几种思路：</p>
<ol>
<li>二分搜索，找可能的碰撞时间<span class="arithmatex">\(t\)</span></li>
<li>约束为三角网格再：</li>
<li>求解重心坐标<span class="arithmatex">\((u,v)\)</span>和<span class="arithmatex">\(t\)</span></li>
<li>简化为三次方程求根</li>
<li>光线投射方法</li>
</ol>
<h4 id="_8">二分法</h4>
<h5 id="irf">IRF</h5>
<blockquote>
<p>Ref:</p>
<ol>
<li>Interval Analysis For Computer Graphics</li>
<li>Interval Methods for Multi-Point Collisions between Time-Dependent Curved Surfaces</li>
</ol>
</blockquote>
<p>逐个检查原点在哪一个时间片中，并迭代缩小时间片。</p>
<p>优点：</p>
<ol>
<li>不会有遗漏的碰撞情况，并且每一步都保证包含 <span class="arithmatex">\(0\)</span>，所以能够确保检查到碰撞</li>
<li>通过改变时间片的允许最小大小，来改变算法的精度和速度</li>
</ol>
<p>缺点：</p>
<ol>
<li>基于二分查找 — 太慢</li>
<li>难以实施编译优化</li>
</ol>
<h5 id="uirf">UIRF</h5>
<p>差不多的思路，但是是用二分法求的是单变量的方程根。</p>
<blockquote>
<p>由于可能出现无穷多个根，所以这个算法必须在定义遇上按最大分辨率逐个检查，从而产生大量的计算浪费。</p>
<p>与此同时，它不能满足控制求解器的运行精度</p>
</blockquote>
<h4 id="_9">针对三角网格的三次方程求解方法</h4>
<blockquote>
<p>Ref:</p>
<ol>
<li>Collision and self-collision handling in cloth model dedicated to design garments</li>
</ol>
</blockquote>
<p>针对于三角网格，上文提出：</p>
<p>Theorem
: 碰撞发生，当且仅当至少发生以下一种碰撞：</p>
<ol>
<li>Vertex-Triangle</li>
<li>Edge-Edge</li>
</ol>
<p>在这篇论文中，还提出了这两类条件的符号语言描述：</p>
<div class="arithmatex">\[
VT\iff \exists t\in [0, 1]\quad \begin{cases}
\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\
\mathbf x_4 \in \left\{ x_1 x_2 x_3 \right\}
\end{cases}
\]</div>
<p>其中：<span class="arithmatex">\(1,2,3\)</span>为三角形顶点，<span class="arithmatex">\(4\)</span>为顶点</p>
<div class="arithmatex">\[
EE\iff \exists t\in [0, 1] \quad \begin{cases}
\left(\mathbf x_{12} \mathbf x_{13}\mathbf x_{14}\right) = 0\\
\left\{\mathbf x_1 \mathbf x_2\right\} \cap \left\{\mathbf x_3 \mathbf x_4\right\} \ne \emptyset
\end{cases}
\]</div>
<p>对于上述两种做法，我们观察到条件中都有一个关于<span class="arithmatex">\(t\)</span>的三次方程（因为每一个<span class="arithmatex">\(\mathbf x_i\)</span>都是关于<span class="arithmatex">\(t\)</span>仿射），因此我们的解决思路就是：</p>
<ol>
<li>求三次方程在<span class="arithmatex">\([0, 1]\)</span>内的根</li>
<li>检查这个根是否满足第二个条件</li>
</ol>
<p>其中的<strong>数值精度</strong>问题体现在：</p>
<ol>
<li>三次方程求解：</li>
<li>不能使用求根公式（误差放大几个数量级） -- 只能用牛顿法求</li>
<li>何时停止迭代</li>
<li>判断是否碰撞时的误差上界？</li>
</ol>
<h5 id="fprf">FPRF</h5>
<p>最老、最经典的一篇论文</p>
<blockquote>
<p>Ref:</p>
<ol>
<li>Collision and self-collision handling in cloth model dedicated to design garments</li>
</ol>
</blockquote>
<p>思想：解三次方程，解出来的解对应函数值是小于一常数，则判断为碰撞。</p>
<p>主要问题：</p>
<ol>
<li>FN太多，即有很多碰撞点不被检测到。</li>
<li>当平行时无法处理 EE 的情况。</li>
</ol>
<p>优点：</p>
<ol>
<li>速度</li>
</ol>
<h5 id="tightccd">TightCCD</h5>
<blockquote>
<p>Ref:</p>
<ol>
<li>TightCCD: Efﬁcient and Robust Continuous Collision Detection using Tight Error Bounds</li>
</ol>
</blockquote>
<p>老朋友了，还是用了单变量的求解，观察三次方程特征来减少计算，观察的是</p>
<div class="arithmatex">\[
Y(0),Y'(0),Y'(1),Y''(0),Y''(1)
\]</div>
<p><img alt="" src="../assets/2022-04-14-19-56-39-20221202161849-cu84nmf.png"/></p>
<p>优点：</p>
<ol>
<li>速度快，准确率也高，几乎是最好的算法</li>
<li>完全没有检测不出的碰撞</li>
</ol>
<p>问题：</p>
<ol>
<li>为了 FN == 0，牺牲了 FP</li>
<li>如果图元在同一平面上移动，它总是检测到碰撞，而与它们的相对位置无关。</li>
</ol>
<h5 id="bsc">BSC</h5>
<blockquote>
<p>Ref:</p>
<ol>
<li>Fast and exact continuous collision detection with bernstein sign classification</li>
</ol>
</blockquote>
<p>通过分解为Bernstein多项式（n=3）来加速CCD。当且仅当其都在拐点同一侧有效，（需要二分求解）</p>
<p>缺点：</p>
<ol>
<li>False Positive + False Negative</li>
</ol>
<blockquote>
<p>实际上这两个思路和我一开始想的是一致的：</p>
<p>既然这是一个三次函数，理论上讲也就四个参数，那么我对于整个区间采样四次，一定能确定这四个参数。但反过来想，确定参数是不能解决问题。因为我们的目标是给出是否在这个时间区间之内有根。</p>
<p>我们在高中时就已经经常做一种题，研究的就是三次函数在几个采样点处的值，然后通过这几个值来确定三次函数的一些性质。一个直观的理解是，通过四个等距采样点上的三次函数值直接判断三次函数是否有解！</p>
</blockquote>
<p>原理上：给定一个三次函数 <span class="arithmatex">\(Y(t)\)</span> 用伯恩斯坦多项式唯一分解，对应了一个三次贝塞尔曲线，而每一个三次贝塞尔曲线可以被分类为</p>
<p><img alt="" src="../assets/image-20220412105920274-20221202161849-7y05pl5.png"/></p>
<p>从而通过观察：</p>
<div class="arithmatex">\[
Y(0), Y(1/3), Y(2/3), Y(1)
\]</div>
<p>（其中 <span class="arithmatex">\(Y\)</span> 即为三次方程对应的函数）的值来减少计算开销并提升精度。</p>
<h4 id="rp-rrp">光线投射 RP / RRP</h4>
<p>转化为光线投射问题：设 <span class="arithmatex">\(\partial \Omega\)</span> 是其边界，通过从原点射出射线，通过观察交点在射线上的位置来判断是否发生碰撞。</p>
<p>问题：</p>
<ol>
<li>实际上只能做DCD – 小TS</li>
<li>容易出现漏报的问题：在 <span class="arithmatex">\([t,t+\Delta t]\)</span> 内有 2 解</li>
</ol>
<p>原理：</p>
<blockquote>
<p>根据 Brouwer topological degree theory：</p>
<p>假设 <span class="arithmatex">\(\Omega\)</span> 是一个 <span class="arithmatex">\(n\)</span> 多面体，设 <span class="arithmatex">\(F:\Omega \rightarrow \mathbb R^{n}\)</span>满足 <span class="arithmatex">\(C^2\)</span>，且有有限多个根，且没有在边界<span class="arithmatex">\(\Gamma=\partial \Omega\)</span> 上的根，在每一个根处的 Jacobian 都非奇异，则若有光线从 <span class="arithmatex">\(0\)</span> 出发，记交点数为 <span class="arithmatex">\(q\)</span> ，<span class="arithmatex">\(F\)</span> 在交点处光滑且不相切于光线，那么 <span class="arithmatex">\(p,q\)</span> 有相同的奇偶性。</p>
</blockquote>
<p>从而得出：对于一个封闭的曲面，一条（起点在外部）射线只能穿过该曲面偶数次（切点算两次）</p>
<h3 id="_10">碰撞处理</h3>
<blockquote>
<p>在这里假设在上一步已经获取了碰撞的时刻（TOI）</p>
<p>Ref:</p>
<ol>
<li>Robust Treatment of Collisions, Contact and Friction for Cloth Animation</li>
</ol>
</blockquote>
<p>根据王老师在GAMES103和2021图形学大会讲的内容（Real-Time Cloth Simulation on GPUs），其程序流程如下：</p>
<p><img alt="A Practical System" src="../assets/image-20220414221444102-20221202161849-0il709f.png"/></p>
<p>前两种方法都是基于如下公式：</p>
<div class="arithmatex">\[
\mathbf x^{k+1} = \arg\min \|\mathbf x - \mathbf x ^ *\|
\]</div>
<p>而Untangle Cloth不基于上式直接进行解除相交问题。</p>
<h4 id="interior-point-method">Interior Point Method 内点法</h4>
<p>思想：添加<span class="arithmatex">\(\log\)</span>边界函数，保持在可行域内，逐步迭代：</p>
<p>优点</p>
<ul>
<li>Always succeed</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能达到局部最优解</li>
<li>需要计算所有的顶点来迭代</li>
<li>小步长 — 速度慢</li>
</ul>
<p><img alt="Interior Point Method" src="../assets/image-20220414221940838-20221202161849-yn4jvup.png"/></p>
<h4 id="impact-zone-optimization">Impact Zone Optimization</h4>
<p>思想：直接从 <span class="arithmatex">\(\mathbf x^*\)</span> 开始迭代，逐步逼进可行域，如下图</p>
<p><img alt="Impact Zone Optimization" src="../assets/image-20220414222918767-20221202161849-unvckjv.png"/></p>
<p>优点：</p>
<ul>
<li>很容易得到一个可能的解。</li>
<li>只需要对不满足约束的点处理</li>
<li>可以使用大步长</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能不收敛到可行域内</li>
</ul>
<h4 id="untangle-cloth">相交解除 — Untangle Cloth</h4>
<blockquote>
<p>Ref</p>
<ol>
<li>Untangle Cloth</li>
<li>Resolving Surface Collisions through Intersection Contour Minimization</li>
</ol>
</blockquote>
<p>当拿到碰撞点后，使用“注水”法，可以直接求出交叉的区域。对于这两个交叉的边界，假设为“紧密贴合”。</p>
<p>优点：</p>
<ol>
<li>保证在绝大部分情况下能够处理</li>
</ol>
<p>缺点：</p>
<ol>
<li>原文中之处理了相交的闭区域，对于边界交叉处理不方便。</li>
<li>物理上不真实</li>
<li>难以在GPU上实现</li>
</ol>
<h4 id="rigid-impact-zone">Rigid Impact Zone</h4>
<p>如果上述方法都失败了，那么就考虑使用该方法，其对于不满足要求的点，直接回退到上一模拟步的状态（无相交的状态）。</p>
<h2 id="_11">非接触方法</h2>
<p>这一类方法都将原有的碰撞条件增强为保持一些点/面之间的距离大于一定值，从而避免 CCD 过程。正如zhihu上所说：</p>
<blockquote>
<p>之前大家试过很多方法，比如定义物体表面距离很近的“点-三角”对和“边-边”对（接触元对）组成的四面体的有符号体积要恒大于0；或者在每个时间歩开始时，找到距离近的每个接触元对上距离最近的点对，限定这些点对的距离大于0等。这些定义的问题在于，如果物体在某个时间歩移动比较多，他们可能无法正确描述无穿透这件事。另外这类方法大多基于sequential quadratic programming优化方法，没法像无约束条件时的牛顿迭代那样方便地通过line search保证稳定收敛。</p>
<p>By Minchen Li.</p>
</blockquote>
<h3 id="ipc">IPC</h3>
<blockquote>
<p>Ref:</p>
<ol>
<li>Incremental potential contact: intersection-and inversion-free, large-deformation dynamics</li>
<li>Medial IPC: accelerated incremental potential contact with medial elastics</li>
<li>Codimensional incremental potential contact</li>
<li>BFEMP: Interpenetration-Free MPM-FEM Coupling with Barrier Contact</li>
</ol>
</blockquote>
<p>主要思路：迭代的每一步，都把所有 primitive pair 分成两类：</p>
<ol>
<li><span class="arithmatex">\(0&lt;\min \mathrm{distance} \le \hat d\)</span>：设置<span class="arithmatex">\(\log\)</span>-barrier 函数，防止直接碰撞</li>
<li><span class="arithmatex">\(\min \mathrm{distance} &gt; \hat d\)</span>：设置迭代最大步长，避免距离在迭代路径上碰撞（穿透）</li>
</ol>
<p>依据这两个基本假设来避免 CCD。</p>
<p>首先，其主要处理的是如何<strong>避免连续碰撞检测</strong>，在论文中，其提出：</p>
<blockquote>
<p>我们称一个状态是可接受的，当且仅当存在一条可行路径，到达该状态，或以该状态为极限。</p>
<p>一个迭代路径是可接受的，当且仅当其可以作为上述的极限过程中的状态序列</p>
</blockquote>
<div class="arithmatex">\[
\mathbf x \in \Omega \iff \exists \mathbf x_i \in \Omega.\ \lim_{i\rightarrow \infty} = \mathbf x
\]</div>
<p>那么，基于以上假设，我们完全可以不去度量是否<strong>产生了</strong>碰撞，而把约束换成</p>
<div class="arithmatex">\[
\|\mathbf x - \mathbf x'\| &gt; 0,\quad \forall \mathbf x' \in \partial \Omega
\]</div>
<p>这样，我们可以将问题转化为：</p>
<div class="arithmatex">\[
\|\mathbf x - \mathbf y\| \ge \epsilon, \forall \mathbf x ,\mathbf y\text{ from different primitives}
\]</div>
<p>那么，可以将动力学方程和约束放在一起求解即：</p>
<div class="arithmatex">\[
\begin{aligned}
\min_{\mathbf x}\quad &amp;F(\mathbf x) + G(\min \mathrm{distance}(\mathbf x))\\
\text{s.t.}\quad &amp;\mathbf x \text{ is feasible}
\end{aligned}
\]</div>
<p>其中：</p>
<ul>
<li><span class="arithmatex">\(F\)</span> 为动力学方程中的能量</li>
<li><span class="arithmatex">\(G\)</span> 为障碍函数</li>
</ul>
<p>这是一个几乎没有约束的优化问题：因为原来的碰撞处理的全套流程转化为在迭代求解过程中，保证迭代路径是可接受的！</p>
<p>具体而言，Log函数为了避免在不充分接近时也出现“抵抗力”，其在保证<span class="arithmatex">\(C^2\)</span>的情况下，构造了如下的“log-barrier”：</p>
<p><img alt="" src="../assets/2022-04-15-08-56-06-20221202161849-xhysasu.png"/></p>
<blockquote>
<p>该方法可以看作是一个“内点法”</p>
</blockquote>
<h4 id="_12">如何计算 “距离”</h4>
<p>IPC方法中并不限于三角网格等具体的空间结构，因此距离的计算并不需要依赖于物体表示的维数。基本思路是通过重心坐标构造两个 primitive 上的点<span class="arithmatex">\(\mathbf x\)</span>和<span class="arithmatex">\(\mathbf y\)</span>，从而计算</p>
<div class="arithmatex">\[
d(\mathbf x, \mathbf y) = \min \|\mathbf x - \mathbf y\|
\]</div>
<p>来得到距离。</p>
<h4 id="constraint-set">Constraint Set</h4>
<p>通过 Spatial Hashing 算法来加速 Constraint Set 计算，定义为：</p>
<div class="arithmatex">\[
\{\langle i , j \rangle | d(\mathbf x_i, \mathbf x_j) \le \hat d \}
\]</div>
<h4 id="_13">迭代过程中如何保证约束</h4>
<p>算法使用 Intersection-Aware Line-Search（回溯线搜索）来进行迭代。并且在每次执行搜索之前，重新计算 Constraint Set。而观察到对于：</p>
<ol>
<li>Constraint Set 中的元素对：一定出现在优化的能量函数中，通过barrier函数避免碰撞</li>
<li>不在其中的元素对：初始距离<span class="arithmatex">\(&gt;\hat d\)</span></li>
</ol>
<p>从而可以通过 <span class="arithmatex">\(\hat d\)</span> 指导迭代的最大步长。</p>
<p>从而将原本难以解决的CCD问题避免。</p>
<h4 id="_14">总结</h4>
<p>优点：</p>
<ol>
<li>不需要繁琐的 CCD -- 速度、精度都有保证</li>
<li>嵌入到 Dynamic Solver 迭代过程中</li>
<li>容易在GPU上实现</li>
</ol>
<p>缺点：</p>
<ol>
<li>非接触方法，摩擦难以解决</li>
</ol>
<h3 id="siggraph-2021-repulsion-method">SIGGRAPH 2021 -- Repulsion Method</h3>
<blockquote>
<p>Ref:</p>
<ol>
<li>A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions</li>
</ol>
</blockquote>
<p>思路：找到使不产生VT/EE碰撞的充分条件，且该充分条件仅需要考虑顶点之间的距离，而和三角网格无关。</p>
<div class="arithmatex">\[
\min d(\mathbf v_i, \mathbf v_j) \ge \hat d = L / 2
\]</div>
<p>其中<span class="arithmatex">\(L\)</span>为三角网格的最大边长。</p>
<p>求解过程分为两部分：</p>
<ol>
<li>Soft-Phase</li>
<li>Hard-Phase</li>
</ol>
<p>并且为了避免约束过强，使用了自适应的重采样方法。</p>
<h4 id="soft-phase">Soft-Phase</h4>
<div class="arithmatex">\[
\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm {init}} \| − \rho \min \left\{c_{ij} (\mathbf x) − \varepsilon_{slack} , 0  \right\}\right\}
\]</div>
<h4 id="hard-phase">Hard-Phase</h4>
<div class="arithmatex">\[
\mathbf x^{k+1} = \arg \min\left\{ \|\mathbf x − \mathbf x^{\mathrm {init}} \| − \mu \sum {
\log (f(c_{ij}(x), \varepsilon_{slack}))
}\right\}
\]</div>
<p>其中的 <span class="arithmatex">\(f\)</span> 是满足 <span class="arithmatex">\(C^1\)</span> 的分段函数：</p>
<div class="arithmatex">\[
f = \begin{cases}
   x &amp; x\le 0\\
   ax^3 + bx^2 + cx + d &amp; 0 &lt;x \le \varepsilon\\
   \varepsilon&amp; \text{otherwise}
\end{cases}
\]</div>
<h4 id="adaptive-resampling">Adaptive Resampling</h4>
<p>由于要求所有距离大于 <span class="arithmatex">\(L / 2\)</span>，为了使得这个条件不是过于充分的，要求最小边长和最大边长<span class="arithmatex">\(l\)</span>与<span class="arithmatex">\(L\)</span>的比例大于一定值。</p>
<p><img alt="" src="../assets/2022-04-15-11-19-43-20221202161849-i3zx5yc.png"/></p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../../../..", "features": ["header.autohide", "navigation.tabs"], "search": "../../../../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.81fa17fe.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>